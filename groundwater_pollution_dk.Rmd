---
title: "groundwater_pollution_dk"
author: "Johan Horsmans"
date: "4/26/2021"
output: github_document
---

### Loading packages
```{r}
library(pacman)

p_load(sf, raster, dplyr, tmap, ggplot2, tidyverse, lubridate, sp, gstat, ggthemes, lmtest)
```

### Loading nitrate data:
```{r}
nitrate <- as.data.frame(read_csv("data/nitrate.csv")) #Load the .csv-file as a dataframe and save it as "nitrate".

#Rename columns to remove spaces:
names(nitrate)[names(nitrate) == "Seneste"] <- "Seneste_m책ling" 
names(nitrate)[names(nitrate) == "Seneste mg/l"] <- "Seneste_mgl"
names(nitrate)[names(nitrate) == "Indtag topdybde"] <- "Indtag_topdybde" 
```

### Remove outliers
```{r}
nitrate <- nitrate %>%
  filter_at(vars("Seneste_mgl"), any_vars(. < 200))

nitrate <- nitrate %>%
  filter_at(vars("Indtag_topdybde"), any_vars(. > 0))
```


### Processing the nitrate.csv-file into a compatible format.
```{r}
nitrate$WKT <- as.character(nitrate$WKT)
nitrate$WKT <- gsub("POINT \\(", "", nitrate$WKT)
nitrate$WKT <- gsub(")", "", nitrate$WKT)
```

### Separate into two columns
```{r}
nitrate <- nitrate %>% 
  separate(col = WKT, into = c("longitude","latitude"), sep = " ")
```

### Making it a shapefile
```{r}
nitrate <- st_as_sf(nitrate, coords = c("longitude", "latitude"))
```

### Loading land-use data.
```{r}
# Loading markblok
markblok <- st_read("data/Markblok.shp") %>% na.omit() 

# Convert to SpatialPolygons-object
markblok <- as_Spatial(markblok$geometry)

# Load ecological fields:
okologimark_2012<-st_read("data/Oekologiske_arealer_2012.shp") %>% na.omit()
okologimark_2013<-st_read("data/Oekologiske_arealer_2013.shp") %>% na.omit()
okologimark_2014<-st_read("data/Oekologiske_arealer_2014.shp") %>% na.omit()
okologimark_2015<-st_read("data/Oekologiske_arealer_2015.shp") %>% na.omit()
okologimark_2016<-st_read("data/Oekologiske_arealer_2016.shp") %>% na.omit()
okologimark_2017<-st_read("data/Oekologiske_arealer_2017.shp") %>% na.omit()
okologimark_2018<-st_read("data/Oekologiske_arealer_2018.shp") %>% na.omit()
okologimark_2019<-st_read("data/Oekologiske_arealer_2019.shp") %>% na.omit()
okologimark_2020<-st_read("data/Oekologiske_arealer_2020.shp") %>% na.omit()

# Merge ecological field-geometry and convert it to SpatialPolygons
okologimark <- c(okologimark_2012$geometry,okologimark_2013$geometry, okologimark_2014$geometry, okologimark_2015$geometry, okologimark_2016$geometry, okologimark_2017$geometry, okologimark_2018$geometry, okologimark_2019$geometry, okologimark_2020$geometry) %>% as_Spatial()


markblok <- markblok[lengths(st_intersects(st_as_sf(markblok),st_as_sf(okologimark)))==0,]


head(markblok)
head(okologimark)
head(nitrate)
```
### Plotting fields
```{r}
plot(okologimark)
```

```{r}
plot(markblok)
```

### Taking subset of conventional fields:
```{r}
markblok_subset <- sample(markblok, length(okologimark))
```


### Setting CRS
```{r}
# Set the projection of the nitrate data as EPSG 25832
nitrate <- st_set_crs(nitrate, value = 25832)

#Set of okologi:
#CRS("+init=epsg:25832")
proj4string(okologimark) <- CRS("+init=epsg:25832")
okologimark <- spTransform(okologimark, CRS("+init=epsg:25832"))

proj4string(markblok) <- CRS("+init=epsg:25832")
markblok <- spTransform(markblok, CRS("+init=epsg:25832"))


# Transform the geometry of the data to the assigned CRS. 
nitrate <- st_transform(nitrate, crs=25832)

# Verify the projection is 'projected' not 'geographic'
head(nitrate)
head(markblok)
head(okologimark)
```

### Filtering dates between 2018 and 2021:
```{r}
nitrate <- nitrate %>%
 select(Seneste_m책ling, Seneste_mgl, geometry, Indtag_topdybde) %>%
 filter(Seneste_m책ling >= as.Date("2012-01-01") & Seneste_m책ling <= as.Date("2021-03-10"))
```

### Remove duplicate entries (for the purpose of kriging)
```{r}
nitrate<-nitrate[!duplicated(nitrate$geometry), ]
```

### Plotting the points
```{r}
plot(st_geometry(nitrate), pch = 16, cex = 0.4)
```

### Plotting points on top of organic fields (to assess CRS allignment)
```{r}
plot(st_geometry(nitrate), pch = 16, cex = 0.4, col = "red")
plot(okologimark, add = TRUE)
```


### Plotting points on top of all conventional fields (to assess CRS allignment)
```{r}
plot(markblok_subset)
plot(st_geometry(nitrate), add = TRUE, pch = 16, cex = 0.4, col = "red")
```


### Exploratory statistics:

Depth:
```{r}
summary(nitrate$Indtag_topdybde)
```

```{r}
sd(nitrate$Indtag_topdybde)
```


### Nitrate:
```{r}
summary(nitrate$Seneste_mgl)
```
```{r}
hist(nitrate$Seneste_mgl)
```

### Plotting points with nitrate per. mg/l metric:
```{r}
ggplot(nitrate) +
  geom_sf(aes(colour = Seneste_mgl)) + theme_solarized() +  scale_colour_gradientn(colors = c("darkgreen", "yellow", "red"))
```


# Data wrangling (converting to list)
```{r}
markblok_polygon_list <- lapply(markblok_subset@polygons, function(x) SpatialPolygons(list(x)))
```


```{r}
nitrate$X <- st_coordinates(nitrate)[,1]
nitrate$Y <- st_coordinates(nitrate)[,2]
```

```{r}
point <- matrix(ncol = 2)


for (i in c(1:length(nitrate$geometry))){
  p <- matrix(c(nitrate$X[i], nitrate$Y[i]), ncol = 2, byrow = TRUE)
  point <- rbind(p, point)
}

point <- point %>% na.omit()

points <- SpatialPoints(point)

markblok_overlap<-lapply(markblok_polygon_list, function(x) over(points, x))

which(sapply(markblok_overlap, function(y) 1 %in% y))

#flat_list <- as.data.frame(do.call(rbind, lapply(markblok_overlap, as.data.frame)))


###
foo = function(x, sep = ".") {
    names(x) = paste0(seq_along(x))
    while(any(sapply(x, class) == "list")) {
        ind = sapply(x, class) == "list"
        temp = unlist(x[ind], recursive = FALSE)
        names(temp) = paste0(rep(names(x)[ind], lengths(x[ind])),
                             sep,
                             sequence(lengths(x[ind])))
        x = c(x[!ind], temp)
    }
    return(x)
}
f2 = foo(markblok_overlap)
indexes<-names(which(unlist(f2) == 1))

indexes <- gsub("^[^.]+.", "", indexes)

indexes<-as.numeric(indexes)

#nitrate$land_type <- "shit"
#nitrate <- nitrate %>% na.omit()

nitrate_depth<-nitrate
nitrate_depth$land_type <- NA


for (i in indexes) {
  nitrate_depth$land_type[i] <- "conventional"
}
###
```

#Same for ECO:
```{r}
eco_polygon_list <- lapply(okologimark@polygons, function(x) SpatialPolygons(list(x)))

```

```{r}
point <- matrix(ncol = 2)


for (i in c(1:length(nitrate$geometry))){
  p <- matrix(c(nitrate$X[i], nitrate$Y[i]), ncol = 2, byrow = TRUE)
  point <- rbind(p, point)
}

point <- point %>% na.omit()

points <- SpatialPoints(point)

eco_overlap<-lapply(eco_polygon_list, function(x) over(points, x))

which(sapply(eco_overlap, function(y) 1 %in% y))

f2 = foo(eco_overlap)
indexes<-names(which(unlist(f2) == 1))

indexes <- gsub("^[^.]+.", "", indexes)

indexes<-as.numeric(indexes)

#nitrate$land_type <- "shit"
#nitrate <- nitrate %>% na.omit()

#nitrate_depth<-nitrate
#nitrate_depth$land_type <- NA


for (i in indexes) {
  nitrate_depth$land_type[i] <- "eco"
}

nitrate_depth <- nitrate_depth %>% na.omit()

```



```{r}
nitrate_depth$land_type <- as.factor(nitrate_depth$land_type)

#
p <- ggplot(nitrate_depth, aes(Indtag_topdybde, colour = land_type))


p + geom_density()


##

p_geom <- ggplot(nitrate, aes(Indtag_topdybde))


p_geom + geom_density()


####
nitrate$land_type <- "all"

p_geom <- ggplot() +
  geom_density(nitrate, mapping = aes(Indtag_topdybde, colour = land_type)) +
  geom_density(nitrate_depth, mapping = aes(Indtag_topdybde, colour = land_type)) + theme_solarized()+ scale_colour_solarized()

p_geom

```


### Kriging:

Creating X- and Y-value columns
```{r}
nitrate$X <- st_coordinates(nitrate)[,1]
nitrate$Y <- st_coordinates(nitrate)[,2]
```


### Make variogram by fitting X- and Y coordinates to nitrate mg/l with a linear regression
```{r}
vgm <- variogram(nitrate$Seneste_mgl ~ X + Y, nitrate)
plot(vgm)
```

ADELAS TEXT: "You might imagine that if soil at a particular point is nutrient-rich, then soil one metre away is likely to be fertile too. But can you say the same thing about soil one kilometre away, or ten kilometres, or one hundred kilometres?"

JOHANS TEXT: "It appears that it is very hard to find spatial correlations in the data. Nonetheles, it appears that the first 30000 (units) are more correlated than those further away. As such, we argue that this model can be used for kriging, since it only needs to interpolate data that is close to "real" data".

Fit a model to the variogram:

```{r}
# Eyeball the variogram and estimate the initial parameters (ADELA TEXT)
nugget <- 550
psill <- 70
range <- 55000
# Fit the variogram (ADELA TEXT)
v_model <- fit.variogram(
  vgm, 
  model = vgm(
    model = "Ste",
    nugget = nugget,
    psill = psill,
    range = range,
    kappa = 0.5
  )
)
# Show the fitted variogram on top of the binned variogram (ADELA TEXT)
plot(vgm, model = v_model)
print(v_model)
```

### Create prediction grid (ALL COMMENTING IS ADELA)
```{r}
st_bbox(nitrate)
# Define a 0.5km square grid over the polygon extent. The first parameter is the bottom left corner.

grid <- GridTopology(c(430734,6040448), c(2000, 2000), c(236, 190))
# Create points with the same coordinate system as the boundary box
crs(nitrate)
gridpoints <- SpatialPoints(grid, proj4string = CRS(projection("+proj=utm +zone=32 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs "))) # CHECK CRS

# Convert to SpatialPixels
spgrid <- SpatialPixels(gridpoints)
coordnames(spgrid) <- c("X", "Y")
plot(spgrid)
```


### Using fitted variogram model to interpolate new data to the grid

ADELA: "Use the spatial pixel grid of the region, `spgrid`, and the variogram model of OM, `v_model` from previous exercises."

```{r}
# Adjust the kaz_geo CRS to be consistent with spgrid
crs(as(nitrate, "Spatial"), asText = TRUE) == crs(spgrid, asText = TRUE)
# Despite the statement above krige() is erroring out due to CRS misalignment, so forcing it here:
nitrate_sp <- as(nitrate, "Spatial")
crs(nitrate_sp) <- crs(spgrid)
# Do kriging predictions over the grid
nitrate_grid <- krige(Seneste_mgl ~ X + Y, nitrate_sp, newdata = spgrid, model = v_model)
# Plot the soil-nutrient predictions in a grid



#UNIQUE:
#Plotting raster:
tm_shape(nitrate_grid[1])  +
  tm_raster(title = "Nitrate mg/l", 
            style = "cont",
            palette = "-RdYlGn") +
  tm_credits(text = "Johan Horsmans & Emil Jessen") +
  tm_layout(main.title = "Nitrate pollution map")


#Points overlayed on raster:
tm_shape(nitrate_grid[1])  +
  tm_raster(title = "Nitrate mg/l", 
            style = "cont",
            palette = "-RdYlGn") +
tm_shape(nitrate) +
  tm_dots()
###

```

### Load DK map
```{r}
DK<-st_read("data/denmark_administrative_outline_boundary.shp")
```

### Inspect CRS
```{r}
head(DK)
```

### Set CRS
```{r}
# Set the projection of the nitrate data as EPSG 25832
DK <- st_set_crs(DK, value = 4326)

# Transform the geometry of the data to the assigned CRS. 
DK <- st_transform(DK, crs=25832)
```

### Inspect CRS
```{r}
head(DK)
```

```{r}
#Plotting raster:
tm_shape(nitrate_grid[1])  +
  tm_raster(title = "Nitrate mg/l", 
            style = "cont",
            palette = "-RdYlGn") +
  tm_credits(text = "Johan Horsmans & Emil Jessen") +
  tm_layout(main.title = "Nitrate pollution map") +
#Points overlayed on raster:
tm_raster(title = "Nitrate mg/l", 
            style = "cont",
            palette = "-RdYlGn") +
tm_shape(nitrate) +
  tm_dots() +
#Adding DK-map
tm_shape(DK) + 
  tm_polygons(alpha = 0.3)

```

```{r}
#Plotting raster:
tm_shape(nitrate_grid[1])  +
  tm_raster(title = "Nitrate mg/l", 
            style = "cont",
            palette = "-RdYlGn") +
  tm_credits(text = "Johan Horsmans & Emil Jessen") +
  tm_layout(main.title = "Nitrate pollution map") +
#Points overlayed on raster:
tm_raster(title = "Nitrate mg/l", 
            style = "cont",
            palette = "-RdYlGn") +
tm_shape(nitrate) +
  tm_dots() +
#Adding DK-map
tm_shape(okologimark) + 
  tm_polygons(col = "lightblue")
```
### Cropped map
```{r}
r <- raster(nitrate_grid)


nitrate_grid_cropped <- crop(r, extent(DK))
nitrate_grid_cropped <- raster::mask(r, DK)

```

```{r}
#Plotting raster:
tm_shape(nitrate_grid_cropped)  +
  tm_raster(title = "Nitrate mg/l", 
            style = "cont",
            palette = "-RdYlGn") +
  tm_credits(text = "Johan Horsmans & Emil Jessen") +
  tm_layout(main.title = "Nitrate pollution map",
            legend.position = c("right","top"),
            legend.bg.color = "white", legend.bg.alpha = .2, 
            legend.frame = "gray50",
            bg.color = "lightblue") +
#Points overlayed on raster:
tm_shape(nitrate) +
  tm_dots() +
#Adding DK-map
tm_shape(DK) + 
  tm_polygons(alpha = 0.3)
```


### ECO
```{r}
r <- raster(nitrate_grid)
#oko_geo <- okologimark$geometry
#okologimark2 <- as_Spatial(oko_geo)
```

```{r}
eco_extraction=suppressWarnings(raster::extract(x=r, y=okologimark, fun=mean, df=TRUE, na.rm=TRUE))

eco_extraction$land_type<-"ecological"

```


### Markblok
```{r}

r <- raster(nitrate_grid)
#mb_geo <- sample(markblok$geometry, length(okologimark))
#markblok2 <- as_Spatial(mb_geo)
```

```{r}
mb_extraction=suppressWarnings(raster::extract(x=r, y=markblok, fun=mean, df=TRUE, na.rm=TRUE))
mb_extraction$land_type<-"conventional"

```

```{r}
t.test(eco_extraction$var1.pred, mb_extraction$var1.pred)
```

```{r}
p_load(lmtest)
```

```{r}
merged<-rbind(eco_extraction, mb_extraction)
```


```{r}
bi_model <- lm(var1.pred ~ land_type, data = merged)

coeftest(bi_model, type = "HC1")

```

### DEPTH PENALTY:
```{r}
nitrate <- as.data.frame(read_csv("data/nitrate.csv")) #Load the .csv-file as a dataframe and save it as "nitrate".

#Rename columns to remove spaces:
names(nitrate)[names(nitrate) == "Seneste mg/l"] <- "Seneste_mgl"
names(nitrate)[names(nitrate) == "Indtag topdybde"] <- "Indtag_topdybde" 

nitrate <- nitrate %>%
  filter_at(vars("Seneste_mgl"), any_vars(. < 200))

nitrate <- nitrate %>%
  filter_at(vars("Indtag_topdybde"), any_vars(. > 0))

p<-ggplot(nitrate, aes(Indtag_topdybde, Seneste_mgl)) +
  geom_point()

  
# loess method: local regression fitting
p + geom_smooth(method = "loess")


```
### Depthpenalty modeling
```{r}

lm(nitrate$Indtag_topdybde ~ poly(nitrate$Seneste_mgl, 2, raw = TRUE), data = nitrate) %>% summary()

```
```{r}
# Andengrads
ggplot(nitrate, aes(Indtag_topdybde, Seneste_mgl) ) +
  geom_point() +
  stat_smooth(method = lm, formula = y ~ poly(x, 5, raw = TRUE))


# Log
ggplot(nitrate, aes(Indtag_topdybde, Seneste_mgl) ) +
  geom_point() +
  stat_smooth(method = lm, formula = y ~ log(x))


ggplot(nitrate, aes(Indtag_topdybde, Seneste_mgl) ) +
  geom_point() +
  stat_smooth(method = lm, formula = log(y) ~ x)

```

### SPLINE MODEL http://www.sthda.com/english/articles/40-regression-analysis/162-nonlinear-regression-essentials-in-r-polynomial-and-spline-regression-models/ 
```{r}
p_load(mgcv)

model <- gam(Seneste_mgl ~ s(Indtag_topdybde), data = nitrate)

model %>% summary()

ggplot(nitrate, aes(Indtag_topdybde, Seneste_mgl) ) +
  geom_point() +
  stat_smooth(method = gam, formula = y ~ s(x))

nitrate$predictions <- model %>% predict(nitrate)

nitrate$penalty <- nitrate$Seneste_mgl-(nitrate$predictions*0.02)


199.2-(31.71734*0.02)

```

